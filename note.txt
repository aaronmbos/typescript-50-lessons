Lesson 11: Typing Objects
 `any` is carefree and careless
 `unknown` is cautious and cause for concern
 - Composite Types
  objects are composite types
  TypeScript is a structural type system
   The structure contract is fulfilled as long as all properties are present for a given type
  All we need to care about is that all the properties needed are available

Lesson 12: Object Type Tool Belt
 `typeof` returns the shape of any object at runtime
 Optional properties are defined with a `?` after the property name

Lesson 13: Typing Classes
 TypeScript erases to JavaScript after the compiler runs
  Compiles down to various versions of ECMAScript
 JavaScript classes work well with TypeScript's type system
 TypeScript is more concerned with the shape of objects instead of the class itself
 Classes are composed of two things
  1. Constructor function
  2. Prototype
 In TypeScript **structure** is important
  Names are sound and smoke
 Classes contribute to value-creation and type-creation

Lesson 14: Interfaces
 Historically interfaces define the blueprint for a class
 If using classes, both types and interfaces can be implemented
 The biggest difference between types and interfaces is **declaration merging**
  For interfaces, declaration merging means we can define the same interface with different properties and they will be merged together
  This is useful for extending objects that we don't own, but use in our code

Chapter 3 Functions

Lesson 15: A Search Function
 Function params are type `any` by default
 Often time function results can be inferred, but explicitly typing them is helpful

Lesson 16: Callbacks
 Complex objects can be defined that contain functions
 Functions are a first-class citizen in JavaScript and can be used as values
  Pass functions to functions as arguments (aka callback function)
  Callbacks are pluggable functions
 TypeScript's structural type system applies to functions as well
  The structure doesn't rely on shape, but by order of arguments and their type

Lesson 17: Substitutability
 TypeScript requires function callers to provide all necessary arguments
 Substitutability comes into play when it is OK to substitute one function for another
  The params don't have to be the same if it won't cause breaking changes
 In JS, all functions have a return value. If the function doesn't return a value explicitly
 the value is undefined
 In TS every function has a return type and if we don't explicitly type or infer, the return type is 
 void by default
 In terms of function return types, anything can be substituted for void
